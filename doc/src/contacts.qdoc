/****************************************************************************
**
** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the Qt Mobility Components.
**
** $QT_BEGIN_LICENSE:LGPL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the Technology Preview License Agreement accompanying
** this package.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights.  These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
**
**
**
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\page contacts.html

\title Contacts
\brief An API enabling clients to request contact data from local or
remote backends.

\ingroup mobility

The Contacts API enables a client to request contact data from local or
remote backends. This is part of the Qt Mobility Project.

\tableofcontents

\section1 Introduction

The Contacts API provides clients with the ability to access contact data
in a platform-independent and datastore-agnostic manner.  This is achieved
by defining generic personal information data abstractions which can
sufficiently describe contact data stored on any platform.  Due to the
cross-platform nature of the API, and the ability for developers to write
platform-independent implementations of a QContactManager which may unify
one or more platform-specific contact backends, it is intended that the
semantics and quirks of the underlying datastores on any platform may be
entirely opaque from the perspective of Qt-based, cross-platform client
applications.

\section1 Overview 

A contact is the digital representation of a person, group or entity,
which is stored in a platform-specific manner. Information pertaining to a
single contact may be located across several different datastores, and each
datum (or detail) may or may not pertain to a particular context in which
that information is valid.  A contact may include semantically identical
pieces of information that are relevant in different contexts.  For
example, a contact may have a phone number that is relevant to their "home"
context, and another phone number that is relevant to their "work" context.
It can be seen that the context of information defines its validity to the
user, depending on the context of usage; and as such, the sum of
information in a given context can be considered equivalent to a "contextual
identity".  This allows great flexibility when consolidating data from
various sources into a single, cohesive contact.

Each datum (or detail) stored in a contact has defined semantics of usage
and storage.  The Qt Contacts API allows per-datastore contact detail
definitions, allowing a manager to provide clients with this information on
demand, and allowing third-party developers to register detail definitions
for use by clients.  A detail definition includes the fields (and value-types
of those fields) which make up the detail, per-contact uniqueness constraints on
details of the definition, and access constraints (such as read-only,
create-only, etc).  Additionally, the fields of a detail definition may
also be constrained to be read-only or not.

A detail is a single, cohesive unit of information that is stored in a
contact.  As explained previously, it is valid for a particular context or
set of contexts, and conforms to a particular definition.  A detail may have
specific metadata associated with it, such as its sub-type, context, and
arbitrary, user-defined metadata.

Contacts may participate in relationships with other contacts.  The details
of any such relationship is stored by the manager which contains the contact.
There are several standard relationship types supported by the default
schema, and arbitrary relationship types are also allowed.  In particular,
membership of a contact in a group can be modeled as that group contact
participating in a \c HasMember relationship with the contact.

Access to the contacts is provided by implementations of the Qt Contacts
manager API. A manager provides access to zero or more platform-specific
datastores.  Each datastore may support different capabilities (for example,
the ability to store certain datatypes, the ability to natively filter on
different details or details of different definitions, the provision of
locking mechanisms, the provision of changelog information, etc) which are
reported by the manager on request.  The manager therefore provides access to
detail definitions, contacts, and relationships stored in different datastores,
in a platform and datastore independent manner. The engine of a manager may
be implemented as a plugin to allow dynamic loading of different engines at
run-time.

The functionality exposed by the QContactManager class may be implemented by
plugins which interface directly to a platform-specific backend or provide
their own data storage backend.  As such, the terms "manager", "plugin" and
"backend" are used interchangeably in this documentation to refer to any plugin
which implements the functionality exposed by the QContactManager interface.

\section1 Using the API

This section provides some examples of common usage of the API.

\section2 Synchronous API Usage

The synchronous API provides the simplest way to access or modify the
contact information managed by a particular backend.  It has the
disadvantage that calls block until completion and is therefore
most suitable only for applications which interact with local, high-speed
datastores, or for applications which do not require a responsive UI.

The synchronous API is offered through the QContactManager class, and includes
manipulation of \l{QContact}{contacts}, \l{QContactRelationship}{contact relationships},
and \l{QContactDetailDefinition}{schema definitions} as well as capability and
metadata information reporting.

For more detailed documentation on the synchronous API, see the \l{Contacts Synchronous API}.

\section2 Asynchronous API Usage

The asynchronous API provides a way to access or modify the
contact information managed by a particular backend via non-blocking,
asynchronous requests.  It is recommended for most
applications that the asynchronous API be used where possible.

The asynchronous API is offered through various classes derived from the
QContactAbstractRequest class, including QContactLocalIdFetchRequest,
QContactFetchRequest, QContactSaveRequest, QContactRemoveRequest,
QContactDetailDefinitionFetchRequest, QContactDetailDefinitionSaveRequest,
QContactDetailDefinitionRemoveRequest, QContactRelationshipFetchRequest,
QContactRelationshipSaveRequest, and QContactRelationshipRemoveRequest.

The asynchronous API allows manipulation of \l{QContact}{contacts}, \l{QContactRelationship}{contact relationships},
and \l{QContactDetailDefinition}{schema definitions}, but does not provide manager capability or
metadata information reporting (which is only available through the \l{Contacts Synchronous API}).

For more detailed documentation on the asynchronous API, see the \l{Contacts Asynchronous API}.

\section2 Contact Details

Once a contact has been created (or retrieved from a manager), the client can retrieve, create,
update or delete details from the contact.  Since QContact and QContactDetail are both container
(value) classes, the API offered for these operations is purely synchronous.

\section3 Viewing a specific detail of a contact

The client retrieves the phone numbers of a contact, and displays the first
one

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Viewing a specific detail of a contact

\section3 Viewing all of the details of a contact

The client retrieves all of the details of a contact, and displays them

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Viewing the details of a contact

It is important to note that details are implicitly shared objects with particular
semantics surrounding saving, removal and modification.  The following example
demonstrates these semantics

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Demonstration of detail sharing semantics

\section1 Manager Settings And Configuration

Users of the contacts API can define which backend they wish to access if a manager
for that backend is available.  The list of available managers can be queried programmatically at
run-time, and the capabilities of different managers can be ascertained by inspecting a
QContactManager instance.  Furthermore, some managers can be constructed
with parameters which affect the operation of the backend.

\section2 Loading the manager for a specific backend

In this example, the client loads a manager for a specific backend.  While
this could be found and retrieved using a more advanced plugin framework
(such as the Qt Service Framework), this code assumes that the client has
prior knowledge of the backend in question.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Loading a specific manager backend

\section2 Loading a manager with specific parameters

The client loads a manager with specific parameters defined.  The
parameters which are available are backend specific, and so the client had
to know that the "Settings" parameter was valid for the particular backend,
and what argument it took. In this example, the client tells the backend to
load detail definitions saved in a particular settings file.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Loading a specific manager backend with parameters

\section1 Building and compiling

This library requires Qt 4.5 to be installed.

To build the library, run \tt qmake and \tt make.

\section1 Reference documentation

\section2 Main classes

\annotatedlist contacts-main

\section2 "Contact Details" Leaf Classes

Several subclasses of \l{QContactDetail} are provided as part of the
Qt Mobility Project Contacts API.  They are general in design but are intended
to fulfil specific use-cases.  Please note that certain backends may
choose not to support one or more of these subclasses as they appear here;
they may offer their own which provide similar functionality.

\annotatedlist contacts-details

Each of these subclasses provide access to information stored in fields which
may have certain constraints, as listed in the \l{Qt Contacts Schema}{schema}.

\section2 Asynchronous Requests

Clients may use either the \l{Contacts Synchronous API}{synchronous}
or \l{Contacts Asynchronous API}{asynchronous} API to access
functionality provided by a manager backend. The
\l{Contacts Asynchronous API}{asynchronous} API is
offered through subclasses of the \l{QContactAbstractRequest} class:

\annotatedlist contacts-requests

\section2 Contact Selection

Clients may select a contact by specifying a unique contact id, or by
supplying a \l{QContactFilter} which matches the contact or contacts they
wish to select.  The various derivatives of \l{QContactFilter} allow for
fine-grained and flexible selection of contacts according to various
criteria:

\annotatedlist contacts-filters


A client can also request that the results of such a selection be sorted,
by passing a \l{QContactSortOrder} (or list of sort orders) to the manager.

\section2 Actions

Clients can perform actions on contacts which support them.  Actions are
things like "Send Email" or "Dial", and can be provided from various
sources including Qt Plugins or the Qt Mobility Service Framework. Every
action implementation is uniquely identified by a combination of its name,
the name of the vendor which provided the implementation, and the version
of the implementation according to the vendor.  These pieces of data may be
encapsulated in a \l{QContactActionDescriptor} which can be used to
retrieve an instance of the implementation from a
\l{QContactActionFactory}.

When an instance of a \l{QContactAction} is created, the caller takes
ownership of the instance, and must delete it after use. 

\section2 Implementing Backends

A manager backend may be implemented by subclassing
\l{QContactManagerEngine}, and providing a \l{QContactManagerEngineFactory}
which can instantiate it when required.

\section2 Manager information and functionality reporting

Different backends have different capabilities and offer different functionality.
In order to allow clients to query the provided functionality at runtime, every
backend must be capable of reporting their functionality and implementation version.  They are
reported to clients through various functions provided by the \l{QContactManager} class.

\section2 Synchronization and Serialization

The contacts API is used by another Qt Mobility module: the \l {Versit API (technology preview)} {Versit}* module.  It allows
serialization of a QContact into a vCard document, and vice versa.

[*] Versit \reg is a trademark of the Internet Mail Consortium.

\section2 Examples

\list
    \o \l{samplephonebook}{Sample Phonebook}
    \o \l{qmlcontacts}{QML-based Sample Phonebook}
\endlist

*/
