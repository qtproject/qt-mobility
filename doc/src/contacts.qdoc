/****************************************************************************
**
** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the Qt Mobility Components.
**
** $QT_BEGIN_LICENSE:LGPL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the Technology Preview License Agreement accompanying
** this package.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights.  These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
**
**
**
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\page contacts.html

\title Contacts
\brief An API enabling clients to request contact data from local or
remote backends.

\ingroup mobility

The Contacts API enables a client to request contact data from local or
remote backends. This is part of the Qt Mobility Project.

\tableofcontents

\section1 Introduction

Access to the backends is provided by implementations of Qt Contacts
manager API.  This is achieved by defining generic personal information
data abstractions which can sufficiently describe contact data stored on
any platform. Due to the cross-platform nature of the API, and the ability
for developers to write platform-independent implementations of a
QContactManager which may unify one or more platform specific contact
backends, it is intended that the semantics and quirks of the underlying
datastores on any platform may be entirely opaque from the perspective of
Qt-based, cross-platform client applications.

\section1 Overview 

A contact is the digital representation of a person, group or entity,
which is stored in a platform-specific manner. Information pertaining to a
single contact may be located across several different datastores, and each
datum (or detail) may or may not pertain to a particular context in which
that information is valid.  A contact may include semantically identical
pieces of information that are relevant in different contexts.  For
example, a contact may have a phone number that is relevant to their "home"
context, and another phone number that is relevant to their "work" context.
It can be seen that the context of information defines its validity to the
user, depending on the context of usage; and as such, the sum of
information in a given context can be considered equivalent to a "contextual
identity".  This allows great flexibility when consolidating data from
various sources into a single, cohesive contact.

Each datum (or detail) stored in a contact has defined semantics of usage
and storage.  The Qt Contacts API allows per-datastore contact detail
definitions, allowing a manager to provide clients with this information on
demand, and allowing third-party developers to register detail definitions
for use by clients.  A detail definition includes the fields (and value-types
of those fields) which make up the detail, per-contact uniqueness constraints on
details of the definition, and access constraints (such as read-only,
create-only, etc).  Additionally, the fields of a detail definition may
also be constrained to be read-only or not.

A detail is a single, cohesive unit of information that is stored in a
contact.  As explained previously, it is valid for a particular context or
set of contexts, and conforms to a particular definition.  A detail may have
specific metadata associated with it, such as its sub-type, context, and
arbitrary, user-defined metadata.

Contacts may participate in relationships with other contacts.  The details
of any such relationship is stored by the manager which contains the contact.
There are several standard relationship types supported by the default
schema, and arbitrary relationship types are also allowed.  In particular,
membership of a contact in a group can be modeled as that group contact
participating in a \c HasMember relationship with the contact.

A manager provides access to zero or more platform-specific datastores.
Each datastore may support different capabilities (for example, the ability
to store certain datatypes, the ability to natively filter on different
details or details of different definitions, the provision of locking
mechanisms, the provision of changelog information, etc) which are reported
by the manager on request.  The manager therefore provides access to detail
definitions, contacts, and relationships stored in different datastores,
in a platform and datastore independent manner. The engine of a manager may
be implemented as a plugin to allow dynamic loading of different engines at
run-time.

\section1 Using the API

This section provides some examples of common usage of the API.

\section2 Synchronous API Usage

The synchronous API provides the simplest way to access or modify the
contact information managed by a particular backend.  It has the
disadvantage that calls block until completion and is therefore
most suitable only for applications which interact with local, high-speed
datastores.

\section3 Saving a new contact to the default manager

The client creates a new contact, adds a name and a phone number, and
saves it to the default store of the default manager.

We assume the existence of a specialised leaf-class that allows simple
access to details of the definition identified by the "PhoneNumber"
identifier, and another that allows simple access to details of the
definition identified by the "Name" identifier.  These specialised leaf
classes may be written by anyone, and simply wrap the functionality
provided by QContactDetail in order to allow simpler access to fields
supported by a particular definition.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Creating a new contact

\section3 Filtering by detail definition and value

The client utilises a default manager and asks for any contacts with a
particular phone number.  The example assumes that the default manager
supports the provided QContactPhoneNumber detail leaf class (which
implements the default definition for phone number details).

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Filtering by definition and value

\section3 Viewing a specific detail of a contact

The client retrieves the phone numbers of a contact, and displays the first
one

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Viewing a specific detail of a contact

\section3 Viewing all of the details of a contact

The client retrieves all of the details of a contact, and displays them

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Viewing the details of a contact

\section3 Installing a plugin that modifies the definition of one type of detail

The client installs a plugin, which requires a new field to be added to
details of the "EmailAddress" definition.  It loads the definition from the
default manager, modifies it (by adding the new field - a label field), and
saves it back.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Installing a plugin which modifies a definition

\section3 Modifying an existing contact and saving the modifications

The client retrieves a contact, modifies one of its details, adds a new
detail, and then saves the contact back to the manager.  Note that it uses
the newly added field of the email address definition!

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Modifying an existing contact

\section2 Asynchronous API Usage

The asynchronous API provides a flexible and powerful method of accessing
and modifying the contact information managed by a particular backend in an
asynchronous manner.  Use of the asynchronous API is slightly more complex
than use of the synchronous API, but offers the programmer greater
flexibility when requesting information from remote or slow, local
datastores.

\section3 Requesting Contacts

The client sets up a request for contacts matching a specific criteria
from a particular manager.

Results from the request will be displayed to the user as they are
received.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Asynchronous contact request

\section3 Other Asynchronous Operations

All other asynchronous operations are performed in a similar manner to the
previous example. A request of the desired type (which is derived from
QContactAbstractRequest) is created, certain criteria are set which
determine the result of the request, and the progress signal of the request
is connected to a slot which deals with the result.  The request can then
be started.

Any operation that may be performed using the synchronous API may also be
performed using the asynchronous API.  It is recommended for most
applications that the asynchronous API be used where possible.

\section1 Manager Settings And Configuration

Users of the contacts API can define which backend they wish to access if a manager
for that backend is available.  The list of available managers can be queried programmatically at
run-time, and the capabilities of different managers can be ascertained by inspecting a
QContactManager instance.  Furthermore, some managers can be constructed
with parameters which affect the operation of the backend.

\section2 Loading the manager for a specific backend

In this example, the client loads a manager for a specific backend.  While
this could be found and retrieved using a more advanced plugin framework
(such as the Qt Service Framework), this code assumes that the client has
prior knowledge of the backend in question.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Loading a specific manager backend

\section2 Loading a manager with specific parameters

The client loads a manager with specific parameters defined.  The
parameters which are available are backend specific, and so the client had
to know that the "Settings" parameter was valid for the particular backend,
and what argument it took. In this example, the client tells the backend to
load detail definitions saved in a particular settings file.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Loading a specific manager backend with parameters

\section1 Building and compiling

This library requires Qt 4.5 to be installed.

To build the library, run \tt qmake and \tt make.

\section1 Reference documentation

\section2 Main classes

\annotatedlist contacts-main

\section2 "Contact Details" Leaf Classes

Several subclasses of \l{QContactDetail} are provided as part of the
Qt Mobility Project Contacts API.  They are general in design but are intended
to fulfil specific use-cases.  Please note that certain backends may
choose not to support one or more of these subclasses as they appear here;
they may offer their own which provide similar functionality.

\annotatedlist contacts-details

Each of these subclasses provide access to information stored in fields which
are listed in the \l{Qt Contacts Schema}{schema}.

\section2 Asynchronous Requests

Clients may use either the synchronous or asynchronous API to access
functionality provided by a manager backend. The asynchronous API is
offered through subclasses of the \l{QContactAbstractRequest} class:

\annotatedlist contacts-requests

\section2 Contact Selection

Clients may select a contact by specifying a unique contact id, or by
supplying a \l{QContactFilter} which matches the contact or contacts they
wish to select.  The various derivatives of \l{QContactFilter} allow for
fine-grained and flexible selection of contacts according to various
criteria:

\annotatedlist contacts-filters


A client can also request that the results of such a selection be sorted,
by passing a \l{QContactSortOrder} (or list of sort orders) to the manager.

\section2 Actions

Clients can perform actions on contacts which support them.  Actions are
things like "Send Email" or "Dial", and can be provided from various
sources including Qt Plugins or the Qt Mobility Service Framework. Every
action implementation is uniquely identified by a combination of its name,
the name of the vendor which provided the implementation, and the version
of the implementation according to the vendor.  These pieces of data may be
encapsulated in a \l{QContactActionDescriptor} which can be used to
retrieve an instance of the implementation from a
\l{QContactActionFactory}.

When an instance of a \l{QContactAction} is created, the caller takes
ownership of the instance, and must delete it after use. 

\section2 Implementing Backends

A manager backend may be implemented by subclassing
\l{QContactManagerEngine}, and providing a \l{QContactManagerEngineFactory}
which can instantiate it when required.

\section2 Manager information and functionality reporting

Different backends have different capabilities and offer different functionality.
In order to allow clients to query the provided functionality at runtime, every
backend must be capable of reporting their functionality and implementation version.  They are
reported to clients through various functions provided by the \l{QContactManager} class.

\section2 Synchronization and Serialization

The contacts API is used by another Qt Mobility module: the \l {Versit API} {Versit}* module.  It allows
serialization of a QContact into a vCard document, and vice versa.

[*] Versit is a trademark of the Internet Mail Consortium.

\section2 Examples

\list
    \o \l{samplephonebook}{Sample Phonebook}
\endlist

*/
