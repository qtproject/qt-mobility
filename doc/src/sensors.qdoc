/****************************************************************************
**
** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the Qt Mobility Components.
**
** $QT_BEGIN_LICENSE:LGPL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the Technology Preview License Agreement accompanying
** this package.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights.  These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
**
**
**
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\page sensors-api.html
\title Sensors API (technology preview)
\brief The Sensors API provides access to hardware sensors.
\ingroup mobility

\warning This API should be considered in a technology preview state. It is
under development and subject to change.

The Sensors API provides access to hardware sensors.

This covers both high-level
sensors such as screen orientation (portrait, landscape) and low-level,
real-time sensors such as accelerometer data.

\tableofcontents

\section1 Overview

There are 2 ways to use a sensor. If you just want the default sensor
for a particular type, instantiate that class.

\code
// On the heap (deleted when this object is deleted)
QAccelerationSensor *sensor = new QAccelerationSensor(this);

// On the stack (eg. to check the orientation on startup)
QOrientationSensor orient_sensor;
\endcode

The QSensorFactory class can also create a sensor for you as well as
listing the available sensors on the device.

The API supports sensors that poll for their data and sensors that push
data to the app as it arrives. Each sensor will support certain update
policies that determine how your application can receive the data from
the sensor.

\section1 Client API

The client API is designed around sub-classes of QSensor. These classes
are instantiated in the client application and connect to a QSensorBackend
instance that either talks directly to hardware or via a system API.
Typically the application will use sub-classes of QSensor from the
QtSensors API but third party sub-classes may be used as well.

\image sensors-overview.png

\section1 Backend API

QSensor instances talk to a backend object. Backends are usually supplied
with the QtSensors library for a specific device although third party
backends may be used as well. A backend may talk
directly to hardware or it may talk to a system service. In some instances
it may even talk to another backend or to another device.
An example of this is the rotation sensor backend for devices that lack
a rotation sensor but have a linear acceleration sensor. This backend
talks directly to an acceleration sensor backend.

\section1 Main Classes
If you want to use the sensors on a device, these are the classes to use.
\annotatedlist sensors

\section1 Helper Classes
These classes provide convenience wrappers that reduce the need for casting.
\annotatedlist sensors_helpers

\section1 Backend Classes
If you are making sensors available through the Sensors API, these are the
classes to use.
\annotatedlist sensors_backend

*/

/*!
\page creating-a-sensor-plugin.html
\title Creating a sensor plugin

\section1 How a sensor plugin is loaded

Since sensor backends are created on demand, the sensor plugin is loaded and asked
to register the sensor backends it handles. The plugin should implement
QSensorPluginInterface::registerSensors() and call QSensorManager::registerBackend()
to register available backends. Typically the plugin will also implement
QSensorBackendFactory::createBackend() in order to instantiate backends it has registered.

The simplest plugin will have just once sensor backend although there is no reason
that multiple sensor backends cannot be in a plugin.

An example follows.

\code
#include "mybackend.h"
#include <qsensorplugin.h>
#include <qsensormanager.h>

class MyPluginClass : public QtMobility::QSensorPluginInterface, public QtMobility::QSensorBackendFactory
{
    Q_OBJECT
    Q_INTERFACES(QtMobility::QSensorPluginInterface)
public:
    void registerSensors()
    {
        QSensorManager::registerBackend(QAccelerationSensor::type, MyBackend::id, this);
    }

    QSensorBackend *createBackend(QSensor *sensor)
    {
        if (sensor->identifier() == MyBackend::id)
            return new MyBackend(sensor);
        return 0;
    }
};

Q_EXPORT_PLUGIN2(libmy_plugin_file_name, MyPluginClass);

#include "main.moc"
\endcode

If you woud like to build a backend into a library or application you can use the
REGISTER_STATIC_PLUGIN() macro although it may not work in all situations as it
uses static initialization.

*/
