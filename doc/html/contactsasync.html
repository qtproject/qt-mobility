<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- contactsasync.qdoc -->
<head>
  <title>Qt Mobility Project 1.1: Contacts Asynchronous API</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">Contacts Asynchronous API<br /><span class="subtitle"></span>
</h1>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#using-the-api">Using the API</a></li>
<ul><li><a href="#contact-manipulation">Contact Manipulation</a></li>
<ul><li><a href="#relationship-manipulation">Relationship Manipulation</a></li>
</ul>
<li><a href="#schema-manipulation">Schema Manipulation</a></li>
</ul>
<li><a href="#examples-of-usage">Examples Of Usage</a></li>
<ul><li><a href="#fetching-contacts">Fetching Contacts</a></li>
<li><a href="#other-asynchronous-operations">Other Asynchronous Operations</a></li>
</ul>
</ul>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>The Contacts Asynchronous API enables a client to asynchronously fetch, update, or remove contact, relationship or schema data from a contact manager. Use of the asynchronous API offers the programmer greater flexibility when requesting information from remote or slow local datastores.</p>
<a name="using-the-api"></a>
<h2>Using the API</h2>
<p>The asynchronous API offered by the Contacts module is available through classes derived from the <a href="qcontactabstractrequest.html">QContactAbstractRequest</a> class. It consists of three major sections:</p>
<ul>
<li>Contact Manipulation</li>
<li>Relationship Manipulation</li>
<li>Schema Manipulation</li>
</ul>
<p>The functionality offered by the synchronous API in these three categories is also available through the asynchronous API. There is one category of functionality which is not provided by the asynchronous API which is provided by the synchronous API: some information and reporting functionality is only provided through the synchronous API.</p>
<p>For detailed information about the information and reporting functionality provided, please refer to the documentation for the <a href="contactssync.html">Contacts Synchronous API</a>.</p>
<p>The functions to set and retrieve the id of the self-contact are also only provided by the synchronous API.</p>
<a name="contact-manipulation"></a>
<h3>Contact Manipulation</h3>
<p>The most common type of operation that clients will perform involves retrieval or modification of contacts. For in-depth information about contact manipulation, please refer to the <a href="contactssync.html">Contacts Synchronous API</a>.</p>
<p>There are four different types of operation which are supported by the asynchronous API:</p>
<ul>
<li>Fetch contact ids</li>
<li>Fetch contacts</li>
<li>Save contacts (create or update)</li>
<li>Remove contacts</li>
</ul>
<p>These operations are supported via the <a href="qcontactlocalidfetchrequest.html">QContactLocalIdFetchRequest</a>, <a href="qcontactfetchrequest.html">QContactFetchRequest</a>, <a href="qcontactsaverequest.html">QContactSaveRequest</a> and <a href="qcontactremoverequest.html">QContactRemoveRequest</a> classes, respectively.</p>
<p>The synchronous API offered by the <a href="qcontactmanager.html">QContactManager</a> class to allow manipulation of contacts consists of the following functions:</p>
<ul>
<li>contactIds(const <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;&amp; sortOrders = <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;()) const</li>
<li>contactIds(const <a href="qcontactfilter.html">QContactFilter</a>&amp; filter, const <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;&amp; sortOrders = <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;()) const</li>
<li>contacts(const <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;&amp; sortOrders = <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;(), const <a href="qcontactfetchhint.html">QContactFetchHint</a>&amp; fetchHint = QContactFetchHint()) const</li>
<li>contacts(const <a href="qcontactfilter.html">QContactFilter</a>&amp; filter, const <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;&amp; sortOrders = <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactsortorder.html">QContactSortOrder</a>&gt;(), const <a href="qcontactfetchhint.html">QContactFetchHint</a>&amp; fetchHint = QContactFetchHint()) const</li>
<li>saveContacts(<a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontact.html">QContact</a>&gt;* contacts, <a href="http://qt.nokia.com/doc/4.6/qmap.html">QMap</a>&lt;int, <a href="qcontactmanager.html#Error-enum">QContactManager::Error</a>&gt;* errorMap)</li>
<li>removeContacts(<a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactid.html#QContactLocalId-typedef">QContactLocalId</a>&gt;* contactIds, <a href="http://qt.nokia.com/doc/4.6/qmap.html">QMap</a>&lt;int, <a href="qcontactmanager.html#Error-enum">QContactManager::Error</a>&gt;* errorMap)</li>
</ul>
<a name="relationship-manipulation"></a>
<h4>Relationship Manipulation</h4>
<p>Contacts may be related in various ways. The contacts API allows clients to define relationships between contacts. For in-depth information about relationship manipulation, please refer to the <a href="contactssync.html">Contacts Synchronous API</a>.</p>
<p>There are three different types of operation which are supported by the asynchronous API:</p>
<ul>
<li>Fetch relationships</li>
<li>Save relationships (create or update, if supported by the backend)</li>
<li>Remove relationships (if supported by the backend)</li>
</ul>
<p>These operations are supported via the <a href="qcontactrelationshipfetchrequest.html">QContactRelationshipFetchRequest</a>, <a href="qcontactrelationshipsaverequest.html">QContactRelationshipSaveRequest</a> and <a href="qcontactrelationshipremoverequest.html">QContactRelationshipRemoveRequest</a> classes respectively.</p>
<p>The synchronous API offered by the <a href="qcontactmanager.html">QContactManager</a> class to allow manipulation of relationships consists of the following functions:</p>
<ul>
<li>relationships(const <a href="qcontactid.html">QContactId</a>&amp; participantId, QContactRelationshipFilter::Role role = QContactRelationshipFilter::Either) const;</li>
<li>relationships(const <a href="http://qt.nokia.com/doc/4.6/qstring.html">QString</a>&amp; relationshipType = <a href="http://qt.nokia.com/doc/4.6/porting4.html">QString</a>(), const <a href="qcontactid.html">QContactId</a>&amp; participantId = QContactId(), QContactRelationshipFilter::Role role = QContactRelationshipFilter::Either) const;</li>
<li>saveRelationship(<a href="qcontactrelationship.html">QContactRelationship</a>* relationship);</li>
<li>saveRelationships(<a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactrelationship.html">QContactRelationship</a>&gt;* relationships);</li>
<li>removeRelationship(const <a href="qcontactrelationship.html">QContactRelationship</a>&amp; relationship);</li>
<li>removeRelationships(const <a href="http://qt.nokia.com/doc/4.6/qlist.html">QList</a>&lt;<a href="qcontactrelationship.html">QContactRelationship</a>&gt;&amp; relationships);</li>
</ul>
<a name="schema-manipulation"></a>
<h3>Schema Manipulation</h3>
<p>The schema supported by a plugin is the list of detail definitions which are supported by the plugin. For in-depth information about the schema, please refer to the <a href="contactssync.html">Contacts Synchronous API</a>.</p>
<p>There are three different types of operation which are supported by the asynchronous API:</p>
<ul>
<li>Fetch detail definitions</li>
<li>Save detail definitions (create or update, if supported by the backend)</li>
<li>Remove detail definitions (if supported by the backend)</li>
</ul>
<p>These operations are supported via the the <a href="qcontactdetaildefinitionfetchrequest.html">QContactDetailDefinitionFetchRequest</a>, <a href="qcontactdetaildefinitionsaverequest.html">QContactDetailDefinitionSaveRequest</a> and <a href="qcontactdetaildefinitionremoverequest.html">QContactDetailDefinitionRemoveRequest</a> classes, respectively.</p>
<p>The synchronous API offered by the <a href="qcontactmanager.html">QContactManager</a> class to allow manipulation of the schema consists of the following functions:</p>
<ul>
<li>detailDefinitions(const <a href="http://qt.nokia.com/doc/4.6/qstring.html">QString</a>&amp; contactType = <a href="qcontacttype.html#TypeContact-var">QContactType::TypeContact</a>) const</li>
<li>detailDefinition(const <a href="http://qt.nokia.com/doc/4.6/qstring.html">QString</a>&amp; definitionName, const <a href="http://qt.nokia.com/doc/4.6/qstring.html">QString</a>&amp; contactType = <a href="qcontacttype.html#TypeContact-var">QContactType::TypeContact</a>) const</li>
<li>saveDetailDefinition(const <a href="qcontactdetaildefinition.html">QContactDetailDefinition</a>&amp; def, const <a href="http://qt.nokia.com/doc/4.6/qstring.html">QString</a>&amp; contactType = <a href="qcontacttype.html#TypeContact-var">QContactType::TypeContact</a>)</li>
<li>removeDetailDefinition(const <a href="http://qt.nokia.com/doc/4.6/qstring.html">QString</a>&amp; definitionName, const <a href="http://qt.nokia.com/doc/4.6/qstring.html">QString</a>&amp; contactType = <a href="qcontacttype.html#TypeContact-var">QContactType::TypeContact</a>)</li>
</ul>
<a name="examples-of-usage"></a>
<h2>Examples Of Usage</h2>
<a name="fetching-contacts"></a>
<h3>Fetching Contacts</h3>
<p>The client sets up a request for contacts matching a specific criteria from a particular manager.</p>
<p>Results from the request will be displayed to the user as they are received.</p>
<pre>    void RequestExample::performRequest()
    {
        <span class="comment">// retrieve any contact whose first name is &quot;Alice&quot;</span>
        QContactDetailFilter dfil;
        dfil.setDetailDefinitionName(QContactName::DefinitionName, QContactName::FieldFirstName);
        dfil.setValue(&quot;Alice&quot;);
        dfil.setMatchFlags(QContactFilter::MatchExactly);

        <span class="comment">// m_fetchRequest was created with m_fetchRequest = new QContactFetchRequest() in the ctor.</span>
        m_fetchRequest-&gt;setManager(this-&gt;m_manager); <span class="comment">// m_manager is a QContactManager*.</span>
        m_fetchRequest-&gt;setFilter(dfil);
        connect(m_fetchRequest, SIGNAL(resultsAvailable()), this, SLOT(printContacts()));
        connect(m_fetchRequest, SIGNAL(stateChanged(QContactAbstractRequest::State)),
                this, SLOT(stateChanged(QContactAbstractRequest::State)));
        if (!m_fetchRequest-&gt;start()) {
            qDebug() &lt;&lt; &quot;Unable to request contacts!&quot;;
            QCoreApplication::exit(0);
        } else {
            qDebug() &lt;&lt; &quot;Requested contacts; awaiting results...&quot;;
        }
    }

    void RequestExample::printContacts()
    {
        QList&lt;QContact&gt; results = m_fetchRequest-&gt;contacts();
        for (m_previousLastIndex = 0; m_previousLastIndex &lt; results.size(); ++m_previousLastIndex) {
            qDebug() &lt;&lt; &quot;Found an Alice:&quot; &lt;&lt; results.at(m_previousLastIndex).displayLabel();
        }
    }

    void RequestExample::stateChanged(QContactAbstractRequest::State state)
    {
        <span class="comment">// once we've finished retrieving results, stop processing events.</span>
        if (state == QContactAbstractRequest::FinishedState
            || state == QContactAbstractRequest::CanceledState) {
            qDebug() &lt;&lt; &quot;Finished displaying asynchronously retrieved contacts!&quot;;
            QCoreApplication::exit(0);
        }
    }</pre>
<a name="other-asynchronous-operations"></a>
<h3>Other Asynchronous Operations</h3>
<p>All other asynchronous operations are performed in a similar manner to the previous example. A request of the desired type (which is derived from <a href="qcontactabstractrequest.html">QContactAbstractRequest</a>) is created, certain criteria are set which determine the intent of the request, and the signals of the request are connected to slots which deals with the results. The request can then be started.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.1.0</div></td>
</tr></table></div></address></body>
</html>
